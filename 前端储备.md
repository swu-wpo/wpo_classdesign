## 页面渲染流程

https://www.jianshu.com/p/e6252dc9be32

### 关键渲染路径

关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给用户能看到的界面这整个过程。

用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源加载完成，分别对应于`DOMContentLoaded`和`Load`。

- `DOMContentLoaded`事件触发时，仅当DOM加载完成，不包括样式表，图片等

- `load`事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成

  

### 浏览器渲染的过程

主要包括以下五步：

1. 浏览器将获取的HTML文档解析成DOM树。
2. 处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。
3. 将DOM和CSSOM合并为渲染树(`rendering tree`)，代表一系列将被渲染的对象。
4. 渲染树的每个元素包含的内容都是计算过的，它被称之为布局`layout`。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。
5. 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制`painting`。

需要注意的是，以上五个步骤并不一定一次性顺序完成，比如DOM或CSSOM被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，JavaScript和CSS的某些操作往往会多次修改DOM或者CSSOM。

![img](https:////upload-images.jianshu.io/upload_images/3534846-00ef9f3d405462ef.png?imageMogr2/auto-orient/strip|imageView2/2/w/624/format/webp)

<center>webkit渲染引擎流程

### 浏览器渲染网页的具体流程

#### 构建DOM树

当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。
 需要注意以下几点：

- DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞
- `display:none`的元素也会在DOM树中
- 注释也会在DOM树中
- `script`标签会在DOM树中

无论是DOM还是CSSOM，都是要经过`Bytes→characters→tokens→nodes→object model`这个过程。

![img](https:////upload-images.jianshu.io/upload_images/3534846-770586311bb543d6?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp)

当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。

#### 构建CSSOM规则树

浏览器解析CSS文件并生成CSSOM，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。
 在这个过程需要注意的是：

- CSS解析可以与DOM解析同时进行。
- CSS解析与`script`的执行互斥 。
- 在Webkit内核中进行了`script`执行优化，只有在JS访问CSS时才会发生互斥。

#### 构建渲染树（Render Tree）

通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。
 有以下几点需要注意：

- Render Tree和DOM Tree不完全对应
- `display: none`的元素不在Render Tree中
- `visibility: hidden`的元素在Render Tree中

![img](https:////upload-images.jianshu.io/upload_images/3534846-610f4ac0a1ad3401.png?imageMogr2/auto-orient/strip|imageView2/2/w/711/format/webp)

渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。

#### 渲染树布局(layout of the render tree)

布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的**盒子模型**，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：

- `float`元素，`absoulte`元素，`fixed`元素会发生位置偏移。
- 我们常说的脱离文档流，其实就是脱离Render Tree。

#### 渲染树绘制（Painting the render tree）

在绘制阶段，浏览器会遍历渲染树，调用渲染器的`paint()`方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。



### 浏览器渲染网页的那些事儿

#### 浏览器主要组件结构

![img](https:////upload-images.jianshu.io/upload_images/3534846-379346e21d0d5c84.png?imageMogr2/auto-orient/strip|imageView2/2/w/400/format/webp)

<center>浏览器主要组件

渲染引擎主要有两个：webkit和Gecko
 Firefox使用Geoko，Mozilla自主研发的渲染引擎。Safari和Chrome都使用webkit。Webkit是一款开源渲染引擎，它本来是为linux平台研发的，后来由Apple移植到Mac及Windows上。
 虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。

#### 渲染阻塞

JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到`<script>`标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在`script`标签上增加属性`defer`或者`async`。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM规则树上。(defer 属性规定是否对脚本执行进行延迟，直到页面加载为止。)

每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以，`script`标签的位置很重要。

JS阻塞了构建DOM树，也阻塞了其后的构建CSSOM规则树，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。

由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染。

**CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在`head`中，仅仅是为了更快的解析CSS，保证更快的首次渲染。**

需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式。

当解析HTML的时候，会把新来的元素插入DOM树里面，同时去查找CSS，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。

例如：`div p {font-size: 16px}`，会先寻找所有`p`标签并判断它的父标签是否为`div`之后才会决定要不要采用这个样式进行渲染）。
 所以，我们平时写CSS时，尽量用`id`和`class`，千万不要过渡层叠。

#### 回流和重绘（reflow和repaint）

我们都知道HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念：`replaint`和`reflow`。

##### reflow（回流）

当浏览器发现**布局**发生了变化，这个时候就需要倒回去**重新渲染**，这个回退的过程叫`reflow`。`reflow`会从`html`这个`root frame`开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。`reflow`几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会`reflow`哪一部分的代码，因为他们会相互影响。

##### repaint（重绘）

`repaint`则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。

需要注意的是，`display:none`会触发`reflow`，而`visibility: hidden`属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框。所以`visibility:hidden`只会触发`repaint`，因为没有发生位置变化。

另外有些情况下，比如修改了元素的样式，浏览器并不会立刻`reflow`或`repaint`一次，而是会把这样的操作积攒一批，然后做一次`reflow`，这又叫异步`reflow`或增量异步`reflow`。但是在有些情况下，比如`resize`窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行`reflow`。

##### 引起reflow

现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。

- 页面第一次渲染（初始化）
- DOM树变化（如：增删节点）
- Render树变化（如：`padding`改变）
- 浏览器窗口`resize`
- 获取元素的某些属性

浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括`offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height`、调用了`getComputedStyle()`。

##### 引起repaint

`reflow`回流必定引起`repaint`重绘，重绘可以单独触发。
 背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）

##### 减少reflow、repaint触发次数

- 用`transform`做形变和位移可以减少`reflow`
- 避免逐个修改节点样式，尽量一次性修改
- 使用`DocumentFragment`将需要多次修改的DOM元素缓存，最后一次性`append`到真实DOM中渲染
- 可以将需要多次修改的DOM元素设置`display:none`，操作完再显示。（因为隐藏元素不在`render`树内，因此修改隐藏元素不会触发回流重绘）
- 避免多次读取某些属性
- 通过绝对位移将复杂的节点元素脱离文档流，形成新的Render Layer，降低回流成本

### 几条关于优化渲染效率的建议

结合上文有以下几点可以优化渲染效率。

- 合法地去书写HTML和CSS ，且不要忘了文档编码类型。
- 样式文件应当在`head`标签中，而脚本文件在`body`结束前，这样可以防止阻塞的方式。
- 简化并优化CSS选择器，尽量将嵌套层减少到最小。
- DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。
- 如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。
- 不要一条条地改变样式，而要通过改变`class`，或者`csstext`属性，一次性地改变样式。
- 尽量用`transform`来做形变和位移
- 尽量使用离线DOM，而不是真实的网页DOM，来改变元素样式。比如，操作`Document Fragment`对象，完成后再把这个对象加入DOM。再比如，使用`cloneNode()`方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。
- 先将元素设为`display: none`（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。
- `position`属性为`absolute`或`fixed`的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。
- 只在必要的时候，才将元素的`display`属性为可见，因为不可见的元素不影响重排和重绘。另外，`visibility : hidden`的元素只对重绘有影响，不影响重排。
- 使用`window.requestAnimationFrame()`、`window.requestIdleCallback()`这两个方法调节重新渲染。



## 网站性能优化

### 构建优化

​    开启gzip,其实后台开启gzip就有效果了，但是需要服务器自己压缩，前端开启gzip是为了节约服务器压缩时间
​    去除console.log
​    去除sourceMap
​    CDN减少打包体积 https://blog.csdn.net/gang456789/article/details/78226410
​    路由懒加载
​    插件按需加载
​    预渲染
​        渲染方式分三种，客户端渲染（seo不友好），服务端渲染（SSR），预渲染

### 网络资源优化

   service worker
    http缓存
        强缓存（200） 协商缓存（304）
        缓存位置：Memory Cache（内存缓存）和 Disk Cache（硬盘缓存）
            内存缓存：读取快、持续时间短、容量小
            硬盘缓存：读取慢、持续时间长、容量大
        缓存优先级：Service Worker -> Memory Cache -> Disk Cache -> Push Cache
    http2 四个新特性
            1.多路复用，无需建立多个TCP链接，在一个http2链接上发起多重请求
            2.二进制分帧，将所有要传输的信息采用二进制编码，并且会将消息分为更小的消息块
            3.头部压缩，用HPACK技术压缩头部，较小保温大小
            4.服务端推送，服务端可以在客户端发起请求前发送数据，换句话说，服务端可以对一个请求发送多个响应，并且资源可以正常缓存
    资源预加载
        preload prefetch dns-prefetch
    异步无阻塞加载js **async defer**
    webbp
        一种新的图片格式，体积只有JPEG的2/3，有兼容问题
    感知性优化
        loading加载，骨架屏

## 懒加载和预加载

### 对比

#### 1)概念

懒加载也叫延迟加载：JS图片延迟加载,延迟加载图片或符合某些条件时才加载某些图片。
预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。

#### 2)区别

两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。

#### 3)懒加载的意义及实现方式

意义：
懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。
实现方式：
1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.
2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。
3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。

实现懒加载有四个步骤，如下：
1.加载loading图片 src中
2.判断哪些图片要加载【重点】
3.隐形加载图片
4.替换真图片

1.加载loading图片是在html部分就实现的，代码如下：

2.如何判断图片进入可视区域是关键。
引用网友的一张图，可以很清楚的看出可视区域。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524164645631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxNDE4ODk5NTMy,size_16,color_FFFFFF,t_70)

如上图所示，让在浏览器可视区域的图片显示，可视区域外的不显示，所以当图片距离顶部的距离top-height等于可视区域h和滚动区域高度s之和时说明图片马上就要进入可视区了，就是说当top-height<=s+h时，图片在可视区。
这里介绍下几个API函数：
页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth (包括边线的宽);
网页可见区域高： document.body.offsetHeight (包括边线的宽);
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;

HTMLElement.offsetTop 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部的距离。
window.innerHeight：浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。

具体实现的js代码为：

// onload是等所有的资源文件加载完毕以后再绑定事件
window.onload = function(){
	// 获取图片列表，即img标签列表
	var imgs = document.querySelectorAll('img');

```js
// 获取到浏览器顶部的距离
function getTop(e){
	return e.offsetTop;
}

// 懒加载实现
function lazyload(imgs){
	// 可视区域高度
	var h = window.innerHeight;
	//滚动区域高度
	var s = document.documentElement.scrollTop || document.body.scrollTop;
	for(var i=0;i<imgs.length;i++){
		//图片距离顶部的距离大于可视区域和滚动区域之和时懒加载
		if ((h+s)>getTop(imgs[i])) {
			// 真实情况是页面开始有2秒空白，所以使用setTimeout定时2s
			(function(i){
				setTimeout(function(){
					// 不加立即执行函数i会等于9
					// 隐形加载图片或其他资源，
					//创建一个临时图片，这个图片在内存中不会到页面上去。实现隐形加载
					var temp = new Image();
					temp.src = imgs[i].getAttribute('data-src');//只会请求一次
					// onload判断图片加载完毕，真是图片加载完毕，再赋值给dom节点
					temp.onload = function(){
						// 获取自定义属性data-src，用真图片替换假图片
						imgs[i].src = imgs[i].getAttribute('data-src')
					}
				},2000)
			})(i)
		}
	}
}
lazyload(imgs);

// 滚屏函数
window.onscroll =function(){
	lazyload(imgs);
}
```
#### 4)预加载的意义及实现方式

**意义:**
预加载可以说是牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映。
**实现方式：**
实现预载的方法非常多，比如：用CSS和JavaScript实现预加载；仅使用JavaScript实现预加载；使用Ajax实现预加载。
常用的是new Image();设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化)。

```js
function loadImage(url, callback) {
    var img = new Image();
    img.src = url;
    if (img.complete) { // 如果图片已经存在于浏览器缓存，直接调用回调函数 防止IE6不执行onload BUG
        callback.call(img);
        return;
    }
    img.onload = function () {
        callback.call(img);//将回调函数的this替换为Image对象
    };
};
```



## 函数节流和函数防抖

### 函数防抖

在事件被触发delay秒后再执行回调，如果在这n秒内又被触发，则重新计时。--->直白：比如click事件，在规定时间内只能执行一次，若多次点击，只执行最后一次；

```js
var input = document.getElementsByTagName('input')[0];
    input.onchange = debounce(function(e) {
        console.log(e.value)
      }, 2000)
      //防抖debounce
    function debounce(fn, delay) {
      var timer = null;
      return function() {
        // var _this = this,
        // _arguments = this.args;
        clearTimeout(timer)
        timer = setTimeout(() => {
          fn(this)
        }, delay)
      }
    }
```

应用：

连续的事件，只需触发一次回调的场景有：

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 手机号、邮箱验证输入检测
- 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

### 函数节流

每隔一段时间，只执行一次函数。--->直白：比如click事件，在规定时间内，就执行一次，其他的点击都是无效的。

```js
//定时器节流。
//利用一个开关switchT控制点击事件，在用一次性定时器在delay内再恢复
    var input = document.getElementsByTagName('input')[0];
    input.onchange = throttles(function(e) {
        console.log(e.value)
      }, 2000)
      // 节流throttles
    function throttles(fn, delay) {
      var switchT = false;
      return function() {
        if (switchT) return;
        switchT = true;
        setTimeout(() => {
          switchT = false;
        }, delay)
        fn(this)
      }
    }

//2 时间戳节流。使用时间来控制，当前时间与之前的时间间隔超过了delay，就可以再次执行

    var input = document.getElementsByTagName('input')[0];
    input.onchange = throttles(function(e) {
        console.log(e.value)
      }, 2000)
      // 节流throttles
    function throttles(fn, delay) {
      var previous = 0;
      return function() {
        var current = new Date();
        if (current - previous < delay) return;
        fn(this)
        previous = current;
      }
    }
```



应用：

间隔一段时间执行一次回调的场景有：

- 滚动加载，加载更多或滚到底部监听
- 谷歌搜索框，搜索联想功能
- 高频点击提交，表单重复提交



## 页面尺寸

网页设计中，宽度的设置，是没有绝对固定的值的，**根据我们的需求出发**

网页宽度一般根据屏幕的分辨率来设计。普遍的网页设计有两种：1920px*1080px、1024x768。内容宽度一般为1000px-1200px。

市面上的电脑屏幕尺寸多种多样，不过大部分都集中在这几种：

1920-1080：目前常用设备中最大的尺寸（Mac 5K屏除外）

1440-900：15寸MacBook Pro为代表，很多UI设计师首选

1366-768：普通的PC电脑

1280-800：13寸MacBook Pro为代表

在以上设备中，13寸和15寸Mac Book，虽然实际分辨率非常大，但由于是Retina屏幕，视觉展示上还属于以上范围。

所以，网站的内容显示宽度大部分都在1200px以内，确保小的电脑屏幕能显示全网页内容。更早的时候很多都是960px，不过由于屏幕越来越大，目前比较少。



## 前端尺寸

https://zhuanlan.zhihu.com/p/96721026

### em

em 是一个相对长度单位。其**相对于当前对象内文本的字体尺寸**。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。

- em的值并不是固定的
- em会继承父级元素的字体大小

结论：

- 我们可以通过设置一个父级元素如html、body font-size,作为整体默认尺寸，通过运行js脚本动态修改font-size实现适配

- 其适配方案依旧是依据像素点来适配

- 需要通过注入脚本实现

- 所有子元素的宽度、高度、font-size等尺寸，均继承与父元素，故增加了我们的计算成本

  

### rem

rem全名root em，简写rem，故其也是一个相对长度单位，但**只相对于根元素**，可以简单的通过更改根元素大小，从而调整所有字体大小。

- 只相对于根元素（html）
- 通过修改根元素可成比例的调整页面字体大小
- 其适配方案通过js脚本设置像素点来实现

其与em的基本用法是一致的，唯独不一致的是，所有元素都是相对于根元素，而不是父级元素，减少了我们的计算成本

总结：

- 用rem，不用em，尺寸清晰，易于维护
- 由于rem是root em，故其与em兼容性是一致的
- 均是基于像素点适配



### vw、vh

vw（Viewport Width）、vh(Viewport Height)是**基于视图窗口**的单位，是css3的一部分，基于视图窗口的单位，除了vw、vh还有vmin、vmax。

- vw:1vw 等于视口宽度的1%
- Vh:1vh 等于视口高度的1%
- vmin: 选取 vw 和 vh 中最小的那个,即在手机竖屏时，1vmin=1vw
- vmax:选取 vw 和 vh 中最大的那个 ,即在手机竖屏时，1vmax=1vh

由于使用vw、vh依赖于视图窗口，故当屏幕分辨率变大或者缩小，尺寸会进行相应的放大或者缩小，当页面足够大，或者足够小时，尺寸会变得很大或者很小，从而导致用户体验差

## 跨域

浏览器不能执行其他网站的脚本，它是由浏览器的同源（***同源是指，域名，协议，端口均相同***）策略造成的，是***浏览器施加的***安全限制。同源才可以相互访问 cookie、localStorage、sessionStorage、发送 ajax 请求，如果三者有一个不同，就是不同源，这时再去访问这些资源就叫做**跨域**。举例如下：

http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）

http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）

http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）

http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）

http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域）

请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。

**浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。**

解决方法：

1、JSONP：

注意JSONP只支持GET请求，不支持POST请求。

核心思想：网页通过添加一个`<script>元素`，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。

```js
// vue.js
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

由于访问 js 文件是没有跨域限制的，我们可以利用这一点来做跨域。具体过程如下：

客户端预先定义好一个 function 用来接收数据，然后动态的创建一个 script 插入到页面中去后端请求数据

```js
function run (data) {
    console.log(data.name)
}

var script = document.createElement('script')
script.src = 'http://xxx.js?callback=run'
document.body.appendChild(script)
```


服务端通过 callback 指定的函数名，将数据传入其中，这样 js 到达客户端就能直接执行函数，把数据传入预先定义好的函数中 run({ name: '张三' })

2、代理：

例如www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于**绕过了浏览器端**，自然就不存在跨域问题。

3、PHP端修改header（XHR2方式）

在php接口脚本中加入以下两句即可：

header('Access-Control-Allow-Origin:*');//允许所有来源访问

header('Access-Control-Allow-Method:POST,GET');//允许访问的方式

## HTML

### 含义

超文本<b>标记语言</b>（标记标签 描述网页）

不是一种编程语言

HTML文档也叫做 web页面

### 结构

![image-20210315104838901](C:\Users\12876\AppData\Roaming\Typora\typora-user-images\image-20210315104838901.png)

白色部分才会在网页中显示



### <!DOCTYPE>声明

告知 Web 浏览器页面使用了哪种 HTML 版本

#### HTML5

<code>< !DOCTYPE html ></code>

#### HTML 4.01

<code>< !DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd" ></code>

#### XHTML 1.0

<code>< !DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" ></code>



### < head >< /head >

#### < title >< /title >

< title > 标签定义了不同文档的标题。

< title > 在 HTML/XHTML 文档中是必须的。

< title > 元素:

- 定义了浏览器工具栏的标题

- 当网页添加到收藏夹时，显示在收藏夹中的标题

- 显示在搜索引擎结果页面的标题

#### < base >

标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接

```
< base href="http://www.runoob.com/images/" target="_blank" >
```

#### < link >

标签定义了文档与外部资源之间的关系。通常用于链接到样式表:

```
<link rel="stylesheet" type="text/css" href="mystyle.css">
```

#### < meta >

描述了一些基本的元数据。

< meta > 标签提供了元数据。元数据也不显示在页面上，但会被浏览器解析。

META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。

元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。



### < body > < /body>



#### < img src='图片路径' width='' height='' >

alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。

< img src="boat.gif" alt="Big Boat" >

在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性是个好习惯，这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。

![image-20210315112305570](C:\Users\12876\AppData\Roaming\Typora\typora-user-images\image-20210315112305570.png)



#### < table >< /table >

![image-20210315112619277](C:\Users\12876\AppData\Roaming\Typora\typora-user-images\image-20210315112619277.png)



#### 列表

无序列表ul + li

有序列表ol + li

自定义列表 dl + dt + dd

![image-20210315113004708](C:\Users\12876\AppData\Roaming\Typora\typora-user-images\image-20210315113004708.png)



#### 区块元素 内联元素

- 区块元素会以新行开始和结束

- 内联元素不会以新行开始

#### < div >< /div >

块级

#### < span >< /span >

 内联



## CSS

### 盒模型

![image-20210401113002160](C:\Users\12876\AppData\Roaming\Typora\typora-user-images\image-20210401113002160.png)

**css3的box-sizing属性给了开发者选择盒模型解析方式的权利。W3C的盒模型方式被称为“content-box”，IE的被称为“border-box”，使用box-sizing: border-box;就是为了在设置有padding值和border值的时候不把宽度撑开。**

#### ie 盒子模型

 **IE 盒子模型的范围包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 padding。**

![IE盒子模型](https://img-blog.csdn.net/20140124141131218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenl1eml4aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



#### 标准 w3c 盒子模型

标准 **W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分**

![标准盒子模型](https://img-blog.csdn.net/20140124141001609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenl1eml4aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

例如一个盒子模型如下：margin:20px,border:10px,padding:10px;width:200px;height:50px;

如果用w3c盒子模型解释，那么这个盒子模型占用的

 宽度为：20*2+10*2+10*2+200=280px;

 高度：20*2+10*2+20*2+50=130px;

 盒子的实际宽度大小为:10*2+10*2+200=240px;

 实际高度：10*2+10*2+50=90px;

用ie的盒子模型解释 ：

盒子在网页中占据的大小为

宽：20*2+200=240px; （width包括了padding和border）

高：20*2+50=90px;

盒子的实际大小为：宽度:200px, 高度:50px;



#### 画三角形

```css
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Document</title>
	</head>
	<style>
		#triangle {
			width: 0px;
			height: 0px;
			border-width: 50px;
			border-style: solid;
			border-color: #000 transparent transparent;/*上 左右 下*/
		}
	</style>
	<body>
		<div id="triangle"></div>
	</body>
</html>

```



![](C:\Users\12876\AppData\Roaming\Typora\typora-user-images\image-20210401110652741.png)

#### 画圆形

```css
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Document</title>
	</head>
	<style>
		 #circle{
		    width:100px;
		    height:100px;
		    border-radius: 50px;
		    background:#000 ;
		  }
	</style>
	<body>
		<div id="circle"></div>
	</body>
</html>

```



![image-20210401112037903](C:\Users\12876\AppData\Roaming\Typora\typora-user-images\image-20210401112037903.png)

在制做圆形之前，首先需要保证这个元素是正方形，即width==height; 其次border-radius=1/2width即可（border-radiusde 的默认基准点是几何中心）

### margin为负值

1.margin-left,margin-right为负值

1）元素本身没有宽度，会增加元素宽度

2）元素本身有宽度，会产生位移

2.margin-top为负值，不管是否设置高度，都不会增加高度，而是会产生向上的位移

3.margin-bottom为负值的时候不会位移,而是会减少自身供css读取的高度.

4.文档流只能是后面的流向前面的，即文档流只能向左或向上流动，不能向下或向右移动。

5.对浮动元素的影响：可以改变元素的布局显示位置，某个元素即使是写在了后面，但可以通过负边距让它在浏览器显示的时候显示在前面 （圣杯布局、双飞翼布局利用此原理实现） 。margin-left: -100% 意思就是向左流动，宽度为100%，即流动到最左边



### *{ margin : 0；padding : 0;}

#### 作用

重置浏览器默认样式，对于各浏览器样式统一的话有着简单粗暴的效果。这东西叫“通配符”用来匹配页面上所有元素。删除浏览器这些默认值，方面后面的设置

#### 优点

简单方便的一次性重置所有HTML网页元素的浏览器样式，代码少，控制量大。

#### 缺点

用*，这样效率会低很多(据说)，因为它重置了所有元素的样式，包括不需要重置的样式，例如table ,我们不需要去重置table元素的样式，所以还需要再为 table 设置默认样式,反而增加了代码量。而且通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。如替代的写法：

**body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td,img {padding:0;margin:0;}**



### 选择器

#### 含义

指定CSS要作用的标签，那个标签的名称就是选择器

#### 分类

|     选择器     |                        选择依据/用法                         |                             符号                             |                             示例                             |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   类别选择器   |      类名 （class），多个元素都可以**重复应用**这个属性      |                            .类名                             |                           .demo{}                            |
|   标签选择器   |                      html标签，指定标签                      |                            标签名                            |                            body{}                            |
|    ID选择器    | 为标有特定ID的HTML元素制定特定的样式，同一ID在同一文档页面中只能出现**一次** |                            #id名                             |                           #demo{}                            |
|   通用选择器   |                        作用于所有元素                        |                              *                               |                             *{}                              |
|   后代选择器   |                     选取某元素的后代元素                     |                             空格                             |                      div p{} div中所有p                      |
|   父子选择器   |                只能选择作为某元素子元素的元素                |                              >                               |        div>p{} div的直接子元素p，p没有被其他标签嵌套         |
| 相邻兄弟选择器 |       选择紧接在另一元素后的元素，且二者有相同父元素。       |                              +                               |          div+p{} div后的第一个p，二者有共同的父元素          |
| 后续兄弟选择器 |              选取所有指定元素之后的相邻兄弟元素              |                              ~                               |           div~p{}div后所有相邻兄弟p，有共同父元素            |
|   伪类选择器   |            CSS伪类是用来添加一些选择器的特殊效果             | selector:pseudo-class {property:value;}<br>selector.class:pseudo-class {property:value;} | a:link {color:#000000;}      /* 未访问链接*/<br/>a:visited {color:#00FF00;}  /* 已访问链接 */<br/>a:hover {color:#FF00FF;}  /* 鼠标移动到链接上 */<br/>a:active {color:#0000FF;}  /* 鼠标点击时 */ |
|   元素选择器   |          具有特定属性的HTML元素样式，不止class和id           | <b>[属性名]:包含有指定属性名的元素（常用）<br/>    [属性名=值]:属性名的值为指定值的元素（常用）<br/></b>    [属性名~=值]:属性名的值包含指定值的元素<br/>    [属性名^=值]:属性名的值以指定值的开头的元素<br/>    [属性名$=值]:属性名的值以指定值的结尾的元素 | input[type="text"] {    width:150px;    display:block;    margin-bottom:10px;    background-color:yellow; } input[type="button"] {    width:120px;    margin-left:35px;    display:block; } |

#### 继承性

- **子元素可以继承父元素的样式，反之不可以。**
- **关于文字样式的属性，都能够继承； 所有关于盒子的、定位的、布局的属性都不能继承。**

继承性都是从自己开始，直到最小的元素。

#### 优先级

- 对于不同类别的选择器，以以下原则进行排序：

  **！important>行内样式>ID选择器>类选择器>标签>通配符>继承>浏览器默认属性**

  同一级别中后写的会覆盖先写的样式。

- 当不同类别的多个选择器混合使用个怎么计算优先级？

  1. 关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）

   标签选择器               |                    计算权重公式 
   ----------------------       | ----------------------------------
   继承或者 *                               0,0,0,0      
   每个元素（标签选择器）       0,0,0,1      
   每个类，伪类                          0,0,1,0      
   每个ID                                      0,1,0,0      
   每个行内样式 style=""            1,0,0,0      
   每个!important                      ∞ 无穷大     

   值从左到右，左面的最大，一级大于一级，**数位之间没有进制，级别之间不可超越。** 
  

  （2）权重叠加

  我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。

  就是一个简单的加法计算

   div ul  li   ------>      0,0,0,3
   .nav ul li   ------>      0,0,1,2
   a:hover      -----—>   0,0,1,1
  .nav a       ------>      0,0,1,1

   注意： 

  数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。

  

  例：div.test1.test3的权值是1+10+10=21，而.test1.test2.test3的权值是10+10+10=30

  选择权值大的，相同则后面定义的覆盖前面的

  ![img](https://img-blog.csdnimg.cn/20200709151449836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2NDk4Mg==,size_16,color_FFFFFF,t_70)

  ! important 的使用：

  ```css
  font-size:60px !important;
  ```

  - !important提升的是一个属性，而不是一个选择器

  - !important无法提升继承的权重，该是0还是0

  - !important不影响就近原则

### 居中

```css
margin: 0 auto;
```



### Position（定位）

五个值：static(默认) relative fixed absolute sticky

元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素

z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）

具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。

**注意：** 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面。



#### static

HTML 元素的默认值，即没有定位，遵循正常的文档流对象。

**静态定位的元素不会受到 top, bottom, left, right影响。**

#### fixed

元素的位置相对于浏览器窗口是固定位置。

即使窗口是滚动的它也不会移动

#### relative

相对定位会按照元素的原始位置对该元素进行移动

即使相对定位元素的内容是移动,预留空间的元素仍保存在正常流动

相对定位元素经常被用来作为绝对定位元素的容器块。

#### absolute

用绝对定位,一个元素可以放在页面上的任何位置

absolute 定位使元素的位置与文档流无关，因此不占据空间。

absolute 定位的元素和其他元素重叠。

#### sticky

基于用户的滚动位置来定位

元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。

这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。



### **布局方式**

1. table布局
2. float布局
3. flex布局
4. 响应式布局
5. Grid布局

#### table布局

table布局在如今已经很少使用，原因是：table布局比其它html标记占更多的字节，会阻挡浏览器渲染引擎的渲染顺序，会影响其内部的某些布局属性的生效。

使用table布局有两种方式

- table标签

- display：table

  

#### float布局

特性：

- 脱离文档流，但不脱离文字流。`文字完全占有`了`图片的空间`并且文字`绕开了图片`可以看出float会脱离文档流但不脱离文本流,并且像文字环绕这种效果经常使用float实现
- 形成块级，被加上float的元素都是块级元素
- 高度塌陷
- 尽量靠上但是如果一行的宽度满足不了浮动元素的要求就会尽量靠左

清除浮动 解决高度塌陷：

- Clear清除浮动：

  ``` css
  .clear{
      clear: both;
  }
  ```

- 父元素添加overflow属性:

  ```css
  .div1 {
  	border: 3px solid black;
  	overflow: hidden; 
  }
  .div1 img{
  	width: 50px;
  	height: 50px;
  	float: left;
  	margin:20px;
  }
  ```

- 伪元素清除浮动



#### flex弹性布局

https://blog.csdn.net/qq_38128179/article/details/80828890

注意事项：

1.内核为webkit的浏览器使用Flex布局时，必须加上 **-webkit-** 前缀

2.给元素设置了Flex布局以后，它的子元素的**float**、**clear**、和**vertical-align**三个属性将会失效。

3.flex和grid有着实质的区别，flex是**一维布局**，flex布局一次只能处理一行或者一列（或者说单轴），而grid布局可以应用多个轴



使用：

- 要使用flex布局，只需在父元素上设置**display: flex** 属性

```css
.flex-container {
   display: -webkit-flex; /* Safari */
   display: flex;
}
```



- 行内元素使用flex布局，在父元素上设置**display: inline-flex**属性

```css
.flex-container {
   display: inline-flex;
}
```



##### 容器属性列表

|      属性      |               描述               |                             选项                             |
| :------------: | :------------------------------: | :----------------------------------------------------------: |
| flex-direction | 决定item的排列方向决定主轴的方向 |        row \| row-reverse \| column \| column-reverse        |
|   flex-wrap    |     item排列不下时，如何换行     |                nowrap \| wrap \| wrap-reverse                |
|   flex-flow    | flex-direction和flex-wrap的简写  |                         row  nowrap                          |
| justify-items  |      item在主轴上的对齐方式      | flex-start \| flex-end \| center \| space-between \| space-around |
|  align-items   |    item在另外一轴上的对齐方式    |   flex-start \| flex-end \| center \| baseline \| stretch    |
| align-content  |        多根轴线的对齐方式        | flex-start \| flex-end \| center \| space-between \| space-around \| stretch |



 ##### item属性列表

|    属性     |                   描述                   |                属性值                |
| :---------: | :--------------------------------------: | :----------------------------------: |
|    order    |            定义item的排列顺序            |      整数，默认为0，越小越靠前       |
|  flex-grow  |      当有多余空间时，item的放大比例      |      默认为0，即有空间也不放大       |
| flex-shrink |       当空间不足时，item的缩小比例       |      默认为1，即空间不足时缩小       |
| flex-basis  |          项目在主轴上占据的空间          |          长度值，默认为auto          |
|    flex     | flex-grow，flex-shrink，flex-basis的缩写 |            默认为0 1 auto            |
| align-self  |          单个item独特的对齐方式          | 同align-items, 可覆盖align-items属性 |



#### 响应式布局

响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够。

1. 最简单的处理方式是加上一个 meta 标签:

```html
<meta name="viewport" content="width=device-width, initial-scale=1">
其中，width = device-width 这一句的意思是让页面的宽度等于屏幕的宽度。
```

- 优点
  - 面对不同分辨率设备灵活性强
  - 能够快捷解决多设备显示适应问题
- 缺点
  - 仅适用布局、信息、框架并不复杂的部门类型网站
  - 兼容各种设备工作量大，效率低下
  - 代码累赘，会出现隐藏无用的元素，加载时间加长
  - 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果
  - 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况
    meta 标签



2. 使用 rem
   rem 指的是 html 元素的 font-size，html 元素的 font-size 默认是 16px，所以 1 rem = 16px；然后根据 rem 来计算各个元素的宽高，然后配合 **media query** 就可以实现自适应。

   **media query**
   css2 允许用户根据特定的 media 类型定制样式，基本语法如下：

```css
@media screen and (max-width: 360px) {  
     html { font-size: 12px;}
}
当屏幕的宽度小于等于 360 px 的时候 html 的字体大小为 12 px。
```

ps：范围大的要放在上面，范围小的放在下面。假设有两个样式，一个适应 360px 以下，一个适应 640px 以下，如果 360px 的放在上面，但是小于 360px 同样满足小于 640px，这就不是我们想要的结果了，所以范围大的需要放在上面。



#### Grid布局（网格布局）

https://blog.csdn.net/weixin_44202459/article/details/88653661?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161700026316780264091884%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161700026316780264091884&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-88653661.pc_search_result_before_js&utm_term=grid&spm=1018.2226.3001.4187

简介：

- CSS Grid（网格）布局，是一个二维的基于网络的布局系统。Flexbox 的出现很大程度上改善了我们的布局方式，但它的目的是为了解决更简单的一维布局，而不是复杂的二维布局（实际上 Flexbox 和 Grid 能协同工作，而且配合得非常好）。Grid(网格) 布局是第一个专门为解决布局问题而创建的 CSS 模块
- 采用grid布局的元素，被称为grid容器(grid container)，简称“容器”。其所有直接子元素（直接子元素的子元素不包含在内）自动成为容器成员，称为grid项目(grid item)，简称“项目”

相关概念：

<b>Grid Container</b>

- 设置了 display: gird 的元素。 这是所有 grid item 的直接父项。 在下面的例子中，.container 就是 grid container

``` html
<div class="container">
  <div class="item item-1"></div>
  <div class="item item-2"></div>
  <div class="item item-3"></div>
</div>
```

<b>Grid Item</b>

- Grid 容器的孩子（直接子元素）。下面的 `.item` 元素就是 grid item，但 `.sub-item`不是

```html
<div class="container">
  <div class="item"></div> 
  <div class="item">
    <p class="sub-item"></p>
  </div>
  <div class="item"></div>
</div>
```

<b>Grid Line</b>

- 这个分界线组成网格结构。 它们既可以是垂直的（“column grid lines”），也可以是水平的（“row grid lines”），并位于行或列的任一侧。 下面例子中的黄线就是一个列网格线

![示意图](https://img-blog.csdnimg.cn/20190319221021515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIwMjQ1OQ==,size_16,color_FFFFFF,t_70)

<b>Grid Track</b>

- 两个相邻网格线之间的空间。 可以把它们想象成网格的列或行。 下面是第二行和第三行网格线之间的网格轨道

![示意图](https://img-blog.csdnimg.cn/20190319221127146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIwMjQ1OQ==,size_16,color_FFFFFF,t_70)

<b>Grid Cell</b>

- 两个相邻的行和两个相邻的列网格线之间的空间。它是网格的一个“单元”。 下面是行网格线1和2之间以及列网格线2和3的网格单元

![示意图](https://img-blog.csdnimg.cn/20190319221206680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIwMjQ1OQ==,size_16,color_FFFFFF,t_70)

<b>Grid Area</b>

- 四个网格线包围的总空间。 网格区域可以由任意数量的网格单元组成。 下面是行网格线1和3以及列网格线1和3之间的网格区域

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190319221246747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIwMjQ1OQ==,size_16,color_FFFFFF,t_70)

##### Grid 属性列表

- Grid Container 的全部属性
  display
  grid-template-columns
  grid-template-rows
  grid-template-areas
  grid-template
  grid-column-gap
  grid-row-gap
  grid-gap
  justify-items
  align-items
  justify-content
  align-content
  grid-auto-columns
  grid-auto-rows
  grid-auto-flow
  grid
- Grid Items 的全部属性
  grid-column-start
  grid-column-end
  grid-row-start
  grid-row-end
  grid-column
  grid-row
  grid-area
  justify-self
  align-self

**新单位fr**: fraction 的缩写，意为"片段" 。可以理解为当前单元格所占该行/列的比例



### overflow属性

#### 介绍

在CSS中，如果设置了一个盒子的宽度与高度，则盒子中的内容就可能超过盒子本身的宽度或高度。此时，可以使用 overflow 属性来控制内容溢出时的处理方式。

overflow属性的可选值有 visible | **hidden** | scroll | auto，除了body 和 textarea 的默认值为auto外，其它元素的默认值为visible。

#### overflow:hidden的作用

1.溢出隐藏：给一个元素中设置overflow:hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位。

2.清除浮动:一般而言，父级元素不设置高度时，高度由随内容增加自适应高度。当父级元素内部的子元素全部都设置浮动float之后，**子元素会脱离标准流，不占位，父级元素检测不到子元素的高度**，父级元素高度为0

```css

/*css样式*/
<style type="text/css">
    .box{ background:skyblue; }
    .kid{ width: 100px;height: 100px; float:left;}
    .kid1{ background: yellow; }
    .kid2{ background: orange; }
    .wrap{ width: 300px; height: 150px; background: blue; color: white; }
</style>
 
/*html*/
<body>
    <div class="box">
        <div class="kid kid1">子元素1</div>
		<div class="kid kid2">子元素2</div>
    </div>
    <div class="wrap">其他部分</div>
</body>

```

![img](https://img-blog.csdn.net/20181023144519537?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM4Nzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

由于父级元素没有高度，下面的元素会顶上去，造成**页面的塌陷**。因此，需要给父级加个overflow:hidden属性，这样父级的高度就随子级容器及子级内容的高度而自适应。如下

修改后：

```css

/*css样式*/
<style type="text/css">
    .box{ background:skyblue; 
	  overflow: hidden;  /*清除浮动*/
	  zoom:1;/*IE低版本，让兼容性更好*/
        }
    .kid{ width: 100px;height: 100px; float:left;}
    .kid1{ background: yellow; }
    .kid2{ background: orange; }
    .wrap{ width: 300px; height: 150px; background: blue; color: white; }
</style>
 
/*html*/
<body>
    <div class="box">
        <div class="kid kid1">子元素1</div>
		<div class="kid kid2">子元素2</div>
    </div>
    <div class="wrap">其他部分</div>
</body>
```



3.解决外边距塌陷：父级元素内部有子元素，如果给子元素添加margin-top样式，那么父级元素也会跟着下来，造成外边距塌陷

```css
<style type="text/css">
    .box{ background:skyblue;}
    .kid{ width: 100px;height: 100px; background: yellow; margin-top: 20px}
</style>
 
<body>
    <div class="box">
		<div class="kid">子元素1</div>
    </div>
</body>
```

![img](https://img-blog.csdn.net/20181023145910705?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM4Nzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

修改后：

```css
<style type="text/css">
    .box{ background:skyblue;
          overflow: hidden; /*解决外边距塌陷*/   
        }
    .kid{ width: 100px;height: 100px; background: yellow; margin-top: 20px}
</style>
 
/*html*/
<body>
    <div class="box">
		<div class="kid">子元素1</div>
    </div>
</body>
```

![img](https://img-blog.csdn.net/20181023150202837?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjM4Nzk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 布局示例

#### 单列布局

![640?wx_fmt=jpeg](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/6OxqSqWBqsLsjJFNyfdok77QdthyDydtNsV1YhGrqJFNAj9icfec23ibtXwMjujW32ibn1CibZ5HEdefsMLjdE9FTA/640?wx_fmt=jpeg)

常见的单列布局有两种：

- header,content 和 footer 等宽的单列布局

  ```css
  <div class="header"></div> 
  <div class="content"></div> 
  <div class="footer"></div> 
  .header{ 
   margin:0 auto; 
   max-width: 960px; 
   height:100px; 
   background-color: blue; 
  } 
  .content{ 
   margin: 0 auto; 
   max-width: 960px; 
   height: 400px; 
   background-color: aquamarine; 
  } 
  .footer{ 
   margin: 0 auto; 
   max-width: 960px; 
   height: 100px; 
   background-color: aqua; 
  } 
  ```

  

- header 与 footer 等宽,content 略窄的单列布局

  

#### 两列自适应布局

两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式

**1.float+overflow:hidden**

如果是普通的两列布局， **浮动+普通元素的 margin** 便可以实现，但如果是自适应的两列布局，利用 **float+overflow:hidden** 便可以实现，这种办法主要通过 overflow 触发 BFC,而 BFC 不会重叠浮动元素。由于设置 overflow:hidden 并不会触发 IE6-浏览器的 haslayout 属性，所以需要设置 zoom:1 来兼容 IE6-浏览器。具体代码如下：

```css
<div class="parent" style="background-color: lightgrey;"> 
 <div class="left" style="background-color: lightblue;"> 
 <p>left</p> 
 </div> 
 <div class="right" style="background-color: lightgreen;"> 
 <p>right</p> 
 <p>right</p> 
 </div> 
</div> 
.parent { 
overflow: hidden; 
zoom: 1; 
} 
.left { 
float: left; 
margin-right: 20px; 
} 
.right { 
overflow: hidden; 
zoom: 1; 
} 
```

注意点:如果侧边栏在右边时，注意渲染顺序。即在 HTML 中，先写侧边栏后写主内容

**2.Flexbox 布局**

Flexbox 布局，也叫弹性盒子布局，区区简单几行代码就可以实现各种页面的的布局。

```css
//html部分同上 
.parent { 
display:flex; 
} 
.right { 
margin-left:20px; 
flex:1; 
} 
```

**3.Grid 布局**

Grid 布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。

```css
//html部分同上 
.parent { 
display:grid; 
grid-template-columns:auto 1fr; 
grid-gap:20px 
} 
```



#### 三栏布局

中间列自适应宽度，旁边两侧固定宽度

##### 浮动布局

```css
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Layout</title>
		<style media="screen">
			html * {
				padding: 0;
				margin: 0;
			}

			.layout article div {
				min-height: 150px;
				overflow: hidden;
			}

			.layout.float .left {
				float: left;
				width: 300px;
				background: red;
			}

			.layout.float .center {
				background: yellow;
			}

			.layout.float .right {
				float: right;
				width: 300px;
				background: blue;
			}
		</style>
	</head>
	<body>
		<!--浮动布局 -->
		<section class="layout float">
			<article class="left-right-center">
				<div class="left">左</div>
				<div class="right">右</div>
				<div class="center">中</div>
			</article>
		</section>
	</body>
</html>
```

这种布局方式，DOM 结构必须是先写浮动部分，然后再中间块，否则右浮动块会掉到下一行。浮动布局的优点就是比较简单，兼容性也比较好。但浮动布局是有局限性的，浮动元素脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如父容器高度塌陷等 。

##### 绝对定位布局

```css
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Layout</title>
		<style>
			.layout.absolute .left-center-right>div {
				position: absolute; //三块都是绝对定位 
			}

			.layout.absolute .left {
				left: 0;
				width: 300px;
				height: 300px;
				background: red;
			}

			.layout.absolute .center {
				right: 300px;
				left: 300px; //离左右各三百 
				height: auto;
				background: yellow;
			}

			.layout.absolute .right {
				right: 0;
				width: 300px;
				height: 300px;
				background: blue;
			}
		</style>
	</head>
	<body>
		<section class="layout absolute">
			<article class="left-center-right">
				<div class="left">左</div>
				<div class="center">中</div>
				<div class="right">右</div>
			</article>
		</section>
	</body>
</html>

```

绝对定位布局优点就是快捷，设置很方便，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。

##### flex布局

```css
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Layout</title>
		<style>
			.layout.flexbox .left-center-right {
				display: flex;
			}

			.layout.flexbox .left {
				width: 300px;
				background: red;
			}

			.layout.flexbox .center {
				background: yellow;
				flex: 1;
			}

			.layout.flexbox .right {
				width: 300px;
				background: blue;
			}
		</style>
	</head>
	<body>
		<section class="layout flexbox">
			<article class="left-center-right">
				<div class="left">左</div>
				<div class="center">中</div>
				<div class="right">右</div>
			</article>
		</section>
	</body>
</html>
```

flexbox 布局是 css3 里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用 flexbox。 flexbox 的缺点就是 IE10 开始支持，但是 IE10 的是-ms 形式的。



##### 表格布局

```css
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Layout</title>
		<style>
			.layout.table .left-center-right {
				display: table;
				height: 150px;
				width: 100%;
			}

			.layout.table .left-center-right>div {
				display: table-cell;
			}

			.layout.table .left {
				width: 300px;
				background: red;
			}

			.layout.table .center {
				background: yellow;
			}

			.layout.table .right {
				width: 300px;
				background: blue;
			}
		</style>
	</head>
	<body>
		<section class="layout table">
			<article class="left-center-right">
				<div class="left">左</div>
				<div class="center">中</div>
				<div class="right">右</div>
			</article>
		</section>
	</body>
</html>
```

表格布局的兼容性很好，在 flex 布局不兼容的时候，可以尝试表格布局。当内容溢出时会自动撑开父元素 。

表格布局也是有缺陷:① 无法设置栏边距；② 对 seo(搜索引擎优化) 不友好；③ 当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，然而有时候这并不是我们想要的效果。

**seo** 难点：原创内容、内部链接结构、高质量外链

![image-20210330160324544](C:\Users\12876\AppData\Roaming\Typora\typora-user-images\image-20210330160324544.png)



##### Grid布局

```css
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Layout</title>
		<style>
			.layout.grid .left-center-right {
				display: grid;
				width: 100%;
				grid-template-columns: 300px auto 300px;
				grid-template-rows: 200px; //行高 
			}

			.layout.grid .left {
				background: red;
				height: 200px;
			}

			.layout.grid .center {
				background: yellow;
				height: 200px;
			}

			.layout.grid .right {
				background: blue;
				height: 200px;
			}
		</style>
	</head>
	<body>
		<section class="layout grid">
			<article class="left-center-right">
				<div class="left">左</div>
				<div class="center">中</div>
				<div class="right">右</div>
			</article>
		</section>
	</body>
</html>
```

CSS Grid 是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让 Web 设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位。但网格布局的兼容性不好。IE10+上支持，而且也仅支持部分属性 



##### 圣杯布局

比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是 dom 结构必须是先写中间列部分，这样实现中间列可以优先加载 。

```css
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Layout</title>
		<style>
			.container {
				padding-left: 220px; //为左右栏腾出空间 
				padding-right: 220px;
			}

			.left {
				float: left;
				width: 200px;
				height: 400px;
				background: red;
				margin-left: -100%;
				position: relative;
				left: -220px;
			}

			.center {
				float: left;
				width: 100%;
				height: 500px;
				background: yellow;
			}

			.right {
				float: left;
				width: 200px;
				height: 400px;
				background: blue;
				margin-left: -200px;
				position: relative;
				right: -220px;
			}
		</style>
	</head>
	<body>
		<article class="container">
			<div class="center">
				<h2>圣杯布局</h2>
			</div>
			<div class="left"></div>
			<div class="right"></div>
		</article>
	</body>
</html>
```

- 三个部分都设定为左浮动， **否则左右两边内容上不去，就不可能与中间列同一行** 。然后设置 center 的宽度为 100%( **实现中间列内容自适应** )，此时，left 和 right 部分会跳到下一行

![640?wx_fmt=jpeg](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/6OxqSqWBqsLsjJFNyfdok77QdthyDydtN3YhARpdYvRGYwUdDNmWMJETSAXaJL0IOlL134zgqPUYrMibBu8mm1A/640?wx_fmt=jpeg)



- 通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行

![640?wx_fmt=jpeg](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/6OxqSqWBqsLsjJFNyfdok77QdthyDydtVTL4vSCDbO9aDXibGy9osDoQDOekibZmPjg9jQywcqsltMiceGl9v3DQA/640?wx_fmt=jpeg)



- 通过设置父容器的 padding-left 和 padding-right，让左右两边留出间隙。

![640?wx_fmt=jpeg](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/6OxqSqWBqsLsjJFNyfdok77QdthyDydticaCicictYdic3LB8kQNt3Wd02H7TBCku3IAa72n9A5w4ibdWrLKDOefJvw/640?wx_fmt=jpeg)



- 通过设置相对定位，让 left 和 right 部分移动到两边。

![640?wx_fmt=jpeg](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/6OxqSqWBqsLsjJFNyfdok77QdthyDydtVFGKtUtaAe4piaoBgOeZ8ibdSk0icgpicdZcZiazz6vdrW6bjs3wFCShTYg/640?wx_fmt=jpeg)



**③ 缺点**

- center 部分的最小宽度不能小于 left 部分的宽度，否则会 left 部分掉到下一行
- 如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正padding+负margin可解决，下文会介绍)

![640?wx_fmt=jpeg](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/6OxqSqWBqsLsjJFNyfdok77QdthyDydtfpkpO2KE50NictLToX8Ggt2XrKD4ra7NE2J4ialqbqMGtqkJpy4Pu6SQ/640?wx_fmt=jpeg)

##### 双飞翼布局

同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题 。

```css
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Layout</title>
		<style>
			.container {
				min-width: 600px; /* //确保中间内容可以显示出来，两倍 left宽+ right宽 */
				overflow: hidden;
			}

			.left {
				float: left;
				width: 200px;
				height: 400px;
				background: red;
				margin-left: -100%;
			}

			.center {
				float: left;
				width: 100%;
				height: 500px;
				background: yellow;
			}

			.center .inner {
				margin: 0 200px; //新增部分 
			}

			.right {
				float: left;
				width: 200px;
				height: 400px;
				background: blue;
				margin-left: -200px;
			}
		</style>
	</head>
	<body>
		<article class="container">
			<div class="center">
				<div class="inner">双飞燕</div>
			</div>
			<div class="left"></div>
			<div class="right"></div>
		</article>
	</body>
</html>
```

**实现步骤(前两步与圣杯布局一样)**

- 三个部分都设定为左浮动，然后设置 center 的宽度为 100%，此时，left 和 right 部分会跳到下一行；
- 通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行；
- center 部分增加一个内层 div，并设 margin: 0 200px；

**缺点**

​	 **多加一层 dom 树节点，增加渲染树生成的计算量** 。

**④ 圣杯布局和双飞翼布局实现方式对比:**

- 两种布局方式都是把主列放在文档流最前面，使主列优先加载。

- 两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。

- 两种布局方式的不同之处在于如何处理中间主列的位置： **圣杯布局是利用父容器的左、右内边距+两个从列相对定位** ; 双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整

  

#### 等高列布局

​	**1.利用背景图片**

​	**2.利用正padding+负margin**

​	**3.模仿表格布局**

​	**4.使用边框和定位**



#### 粘连布局

**1.特点**

- 有一块内容 <main> ，当 <main> 的高康足够长的时候，紧跟在 <main> 后面的元素 <footer> 会跟在 <main> 元素的后面。
- 当 <main> 元素比较短的时候(比如小于屏幕的高度),我们期望这个 <footer> 元素能够“粘连”在屏幕的底部

**2.实现步骤**

**(1)footer 必须是一个独立的结构，与 wrap 没有任何嵌套关系**

**(2)wrap 区域的高度通过设置 min-height，变为视口高度**

**(3)footer 要使用 margin 为负来确定自己的位置**

**(4)在 main 区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。**



## JavaScript

### 普通函数和箭头函数

```js
var a = () => {
  return 1;
}

function a() {
  return 1;
}
```

#### 区别

- 箭头函数作为匿名函数,是**不能作为构造函数**的,不能使用new

```jsx
var B = ()=>{
  value:1;
}

var b = new B(); //TypeError: B is not a constructor
```

- 箭头函数不绑定arguments,取而代之用**rest参数…**解决

```jsx
function A(a){
  console.log(arguments); //[object Arguments] {0: 1}
}

var B = (b)=>{
  console.log(arguments); //ReferenceError: arguments is not defined
}

var C = (...c)=>{ //...c即为rest参数
  console.log(c); //[3]
}
A(1);
B(2);
C(3);
```

- 箭头函数会捕获其所在**上下文的 this 值，作为自己的 this 值**

```jsx
var obj = {
  a: 10,
  b: function(){
    console.log(this.a); //10
  },
  c: function() {
     return ()=>{
           console.log(this.a); //10
     }
  }
}
obj.b(); 
obj.c()();
```

- 箭头函数当方法使用的时候**没有定义this绑定**

这句话是`MDN`里面写的，但是我觉得这条和上条其实是一条，还是捕获所在的上下文，比如下面这个例子：`b`是一个箭头函数，然后它的 `this`是指向`window`，这是为什么呢，因为箭头函数捕获的是`obj{}`这个对象的环境，然后这个环境的`this`指向的是`window`，就相当于上一条的例子：在`c`方法里面`return`的那个箭头函数捕获的是`c:function(){}`这个环境的`this`，而这个环境的`this`是`obj`，这样是不是就清晰明了了

```jsx
var obj = {
  a: 10,
  b: () => {
    console.log(this.a); //undefined
    console.log(this); //window
  },
  c: function() {
    console.log(this.a); //10
    console.log(this); //obj{...}
  }
}
obj.b(); 
obj.c();
```

- 通过 `call()` 或 `apply()` 方法调用一个函数时，只是传入了参数而已，**对 `this`并没有什么影响**

```jsx
var obj = {
  a: 10,
  b: function(n){
    var f = (v) => v + this.a;
    return f(n);
  },
  c: function(n) {
    var f = (v) => v + this.a;
    var m = {a:20};
    return f.call(m,n);
  }
}

console.log(obj.b(1)); //11
console.log(obj.c(1)); //11
```

- 箭头函数**没有原型属性**

```jsx
var a = ()=>{
  return 1;
}

function b(){
  return 2;
}

console.log(a.prototype);//undefined
console.log(b.prototype);//object{...}
```

- 箭头函数不能当做Generator函数,不能使用yield关键字

- 箭头函数**不能换行**

```jsx
var a = ()
          =>1; //SyntaxError: Unexpected token =>
```

对于函数的`this`指向问题，我总结了下面两句话：

1. 箭头函数的`this`永远指向其上下文的 `this`，**任何方法都改变不了其指向**，如`call(), bind(), apply()`

2. 普通函数的`this`指向调用它的那个对象

   

### rest 参数 与 arguments 对象

rest 参数与 arguments 对象的区别：
 1）rest 参数**只包含那些没有对应形参的实参**，而 arguments 对象包含了传给函数的所有实参。
 2）arguments对象不是一个真正的数组，而 rest 参数是**真正的 Array 实例**，也就是说你能够在它上面直接使用所有的数组方法，比如 sort、map、forEach、pop
 3）arguments对象还有一些附加的属性 （如callee属性）

> arguments 对象

arguments 对象是所有非箭头函数中的函数内部变量（arguments 对象并不是在 ES6 中提出的）

```xml
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</style>
</style>
</head>
<body>
    <script>
        function fn() {
            console.log(arguments);

            for (var i=0; i<arguments.length; i++) {
                console.log(arguments[i]);
            }
        }
        
        // Arguments(5) [1, 3, 5, 7, 9, callee: ƒ, Symbol(Symbol.iterator): ƒ]
        // 1
        // 3
        // 5
        // 7
        // 9
        fn(1,3,5,7,9);
    </script>
</body>
</html>
```

> rest 参数

rest 参数又叫剩余参数。它允许我们将一个或多个不定数量的实参表示为一个数组。

```xml
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</style>
</style>
</head>
<body>
    <script>
        function fn(...args) {
            console.log(args);
        }
        
        // (5) [1, 3, 5, 7, 9]
        fn(1,3,5,7,9);

        function f(a, b, ...args) {
            console.log(args);
        }
        
        // (3) [5, 7, 9]
        f(1,3,5,7,9);

        // []
        f(1,3);
    </script>
</body>
</html>
```



### BOM

#### 概述

- BOM是Browser Object Model的缩写，简称浏览器对象模型

- BOM提供了独立于内容而与浏览器窗口进行交互的对象

- 由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window

- BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性

- BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C（WHATWG,WebHypertextApplicationTechnologyWorkingGroup——网页超文本应用程序技术工作组目前正在努力促进BOM的标准化）

- BOM最初是Netscape浏览器标准的一部分

  

#### 体系结构图

![img](http://images.cnitblog.com/blog/322408/201312/01223839-f7553ee1608a43558ec2c71f487b169b.png)



#### 对象说明

window -- window对象是BOM中所有对象的核心。window对象表示整个浏览器窗口，但不必表示其中包含的内容。此外，window还可用于移动或调整它表示的浏览器的大小，或者对它产生其他影响。

JavaScript中的任何一个全局函数或变量都是window的属性

window子对象

- document 对象
- frames 对象
- history 对象
- location 对象
- navigator 对象
- screen 对象

##### window

**window对象**的方法
**窗体控制**
moveBy(x,y)——从当前位置水平移动窗体x个像素，垂直移动窗体y个像素，x为负数，将向左移动窗体，y为负数，将向上移动窗体
moveTo(x,y)——移动窗体左上角到相对于屏幕左上角的(x,y)点，当使用负数做为参数时会吧窗体移出屏幕的可视区域
resizeBy(w,h)——相对窗体当前的大小，宽度调整w个像素，高度调整h个像素。如果参数为负值，将缩小窗体，反之扩大窗体
resizeTo(w,h)——把窗体宽度调整为w个像素，高度调整为h个像素
**窗体滚动轴控制**
scrollTo(x,y)——在窗体中如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置
scrollBy(x,y)—— 如果有滚动条，将横向滚动条移动到相对于当前横向滚动条的x个像素的位置(就是向左移动x像素)，将纵向滚动条移动到相对于当前纵向滚动条高度为y个像素的位置(就是向下移动y像素)
**窗体焦点控制**
focus()—— 使窗体或控件获取焦点
blur()——与focus函数相反，使窗体或控件失去焦点
**新建窗体**
open()——打开(弹出)一个新的窗体
close()——关闭窗体
opener属性——新建窗体中对父窗体的引用，中文"开启者"的意思

**对话框**
alert(str)—— 弹出消息对话框（对话框中有一个“确定”按钮）
confirm(str)—— 弹出消息对话框（对话框中包含一个“确定”按钮与“取消”按钮）
prompt(str,defaultValue)——弹出消息对话框（对话框中包含一个“确定”按钮、“取消”按钮与一个文本输入框），由于各个浏览器实现的不同，若没有第二个参数（文本框中的默认值）时也最好提供一个空字符串
**状态栏**
window.defaultStatus 属性——改变浏览器状态栏的默认显示(当状态栏没有其它显示时)，浏览器底部的区域称为状态栏，用于向用户显示信息
window.status 属性——临时改变浏览器状态栏的显示
**时间等待与间隔函数**
setTimeout()—— 暂停指定的毫秒数后执行指定的代码
clearTimeout()——取消指定的setTimeout函数将要执行的代码
setInterval()——间隔指定的毫秒数不停地执行指定的代码
clearInterval()——取消指定的setInterval函数将要执行的代码

##### History
History 对象的属性:**length** 返回浏览器历史列表中的 URL 数量

History 对象的方法

back() 加载 history 列表中的前一个 URL
forward() 加载 history 列表中的下一个 URL
go(num) 加载 history 列表中的某个具体页面

##### Location 
Location 对象的属性

hash 设置或返回从井号 (#) 开始的 URL（锚）
host 设置或返回主机名和当前 URL 的端口号
hostname 设置或返回当前 URL 的主机名
href 设置或返回完整的 URL
pathname 设置或返回当前 URL 的路径部分
port 设置或返回当前 URL 的端口号
protocol 设置或返回当前 URL 的协议
search 设置或返回从问号 (?) 开始的 URL（查询部分）

Location 对象的方法

assign() 加载新的文档,这与直接将一个URL赋值给Location对象的href属性效果是一样的
reload() 重新加载当前文档，如果该方法没有规定参数，或者参数是 false，它就会用 HTTP 头 **If-Modified-Since** 来检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。如果把该方法的参数设置为 true，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift 健的效果是完全一样。
replace() 用新的文档替换当前文档，replace() 方法**不会在 History 对象中生成一个新的记录**。当使用该方法时，新的 URL 将覆盖 History 对象中的当前纪录。

##### **Navigator**
Navigator 对象的属性

appCodeName 返回浏览器的代码名
appName 返回浏览器的名称
appVersion 返回浏览器的平台和版本信息
browserLanguage 返回当前浏览器的语言
cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值
cpuClass 返回浏览器系统的 CPU 等级
onLine 返回指明系统是否处于脱机模式的布尔值
platform 返回运行浏览器的操作系统平台
systemLanguage 返回 OS 使用的默认语言
userAgent 返回由客户机发送服务器的 user-agent 头部的值
userLanguage 返回 OS 的自然语言设置



### async 与 await

#### 使用原因

用于解决回调函数嵌套问题，使代码可读性更高，解决回调地狱问题

#### 功能简介

- async用于修饰一个函数, 表示一个函数是异步的
- await必须写在 async函数中, 一般后面跟的 promise对象, 会**等待 promise成功的结果**
- await只会等待成功的结果, 失败了会报错, 报错需要通过 .catch() 方法处理
- await会阻塞 async函数的执行, 让代码可读性更高
- async 和 await是一对关键字，必须要**成对使用才有效果**。



 ### 闭包

ECMAScript中，闭包指的是：

从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。
从实践角度：以下函数才算是闭包：
即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
在代码中引用了自由变量

- 函数内的所有内部函数都共享一个父作用域，因此创建的闭包是共用的。
- 利用闭包隔离作用域的特性可以解决共享作用域的问题



### 执行上下文

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020061510512845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200615113052649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2piajY1Njg4Mzl6,size_16,color_FFFFFF,t_70#pic_center)



## Webpack

https://webpack.docschina.org/

Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。

从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。

![image-20210122221026758](https://img-blog.csdnimg.cn/img_convert/8b02761f730d2b3a6ba9b19b7fa4361a.png)